'''
This defines abstract / interface classes used by a Perspective Broker Server
The names of the classes are subject to change... my feelings won't be upset if
we change or decide on more logical and consistent naming conventions
'''

from twisted.spread import pb
from twisted.python import log, reflect
from twisted.internet import defer,reactor
import inspect
import sys
import imp
import os
import os.path

__version__ = "0.2.1"

class EasyReferenceable(pb.Referenceable):
	'''
	I am an object sent remotely as a direct reference.
	The Remote side of the connection will be able to call my methods.

	Methods that begin with ( _ ) underscore are private and cannot be called
	remotely.

	Method names are translated EXACTLY you DO NOT NEED TO PREFIX THEM WITH 
	"remote_" ... The client-side behavior is identical to the regular
	pb.Referenceable...

	Methods of this class may return Deferred objects, and may also implement
	@inlineCallbacks
	'''
	def remoteMessageReceived(self, broker, message, args, kw):
		args = broker.unserialize(args)
		kw = broker.unserialize(kw)
		method = getattr(self, message, None)

		if method is None:
			raise NoSuchMethod("No such method: %s" % (message,))
		if(message[0] == '_'):
			raise AttributeError("Methods that begin with underscore ( _ ) characters cannot be called remotely!")
		try:
			state = method(*args, **kw)
		except TypeError:
			log.msg("%s didn't accept %s and %s" % (method, args, kw))
			raise
		return broker.serialize(state, self.perspective)


class PbApplication(object, EasyReferenceable):
	'''
	Superclass for all PB Applications
	Your main application class should subclass this class.

	The application class is a mix of instance methods, and class methods.
	The class methods provide mechanisms to interact with the Application API
	The instance methods allow you to interact with your Application Root Object
	which is a referencable.

	self.server is a reference to this servers object, and is how you can
	communicate and get references to other applications, and global 
	configuration data.
	
	
	
	Class Attributes:
	
	*__modules* (``dict``) contains the ``module``s loaded by the
	application class.
	'''
	#TODO: Can this be notified on client disconnect? - protocol is aware of this...
	
	'''
	# This has been simplified with the _server_register() method.
	class __metaclass__(type):
		"""
		Black magic to ensure each PbApplication subclass gets its own
		*__modules* dict.
		"""
		
		def __new__(metacls, name, bases, attrs):
			if name == 'PbApplication': 
				attrs['_PbApplication__modules'] = {}
			return type.__new__(metacls, name, bases, attrs)
	'''
			
	def __init__(self, server):
		'''
		You should never define this method in a subclass!
	
		Args:
			server[PbServer] a Pb.Root object that implements the server functionality
			You request/load applications through the server object.
		'''
		self.server = server

	def clientConnectionMade(self, nothing=None):
		'''
		Called when a client first connects to this application module.

		You may perform initialization inside of this method during the
		instantiation of this class, establishing database connections, or
		preparing the application broker for use by the client can be done here

		This method may return a deferred.  The return 'value' is ignored.
		'''
		pass
		
	@defer.inlineCallbacks
	def new(self, modulename, classname):
		'''
		Instantiate a new Referenceable, by specifying a package/module to load
		from and a classname to instantiate.

		This method provides a python-like importing capability for Perspective
		Broker clients.  Any application-module inherits this functionality.

		The path the application module resides in is searched first.

		Args:
			modulename[str] A fully qualified package / module path separated by dots (.) - "package.subpackage.module"
			classname[str]  The name of the class or a module attribute that contains one.
		'''
		if modulename in self.__modules:
			# Module already loaded.
			module = self.__modules[modulename]
		else:
			parts = modulename.split('.')
			basepath = self.server.app_path(self.__class__.__name__)
			count = len(parts)
			module = None
			
			# Load module and all packages leading up to the module.
			for i, pkgname in enumerate(parts):
				pkgfqn = '.'.join(parts[:i+1])
				if pkgfqn in self.__modules:
					# The package is already loaded.
					continue
				
				searchpath = os.path.join(basepath, *parts[0:i])
				fh, pathname, desc = imp.find_module(pkgname, [searchpath])
				try:
					module = imp.load_module(pkgfqn, fh, pathname, desc)
				finally:
					if fh:
						fh.close() 
				
				self.__modules[pkgfqn] = module
		
		# Get class.
		if not hasattr(module, classname):
			raise AttributeError("Module %r is missing attribute %r in %r." % (modulename, classname, module.__file__))
		cls = getattr(module, classname)
		if not inspect.isclass(cls):
			raise TypeError("Module %r attribute %r is not a class in %r." % (modulename, classname, module.__file__))
		elif not issubclass(cls, pb.Referenceable):
			raise TypeError("Module %r class %r is not a subclass of %r in %r." % (modulename, classname, "%s.%s" % (pb.Referenceable.__module__, pb.Referenceable.__name__), module.__file__))
		
		# Instantiate referenceable.
		ref = cls()
		
		# Call referenceable's deferred init method.
		yield defer.maybeDeferred(ref.clientConnectionMade, self)
		
		# Return referenceable.
		defer.returnValue(ref)
		
		'''
		# -- LOAD FROM APPLICATION PATH ----------------------------------------
		try:
			parts = modulename.split('.')
			bpath = self.server.app_path(self.__class__.__name__)
			size = len(parts)
			module = modname = None
			
			for i, pkgname in enumerate(parts):
				#Calculate the packages path based on the Application's path.
				pkgfqn = '.'.join(parts[0:i+1])
				impname = '__init__'
				fpath = os.path.join(bpath, *parts[0:i])

				fp, pathname, description = imp.find_module(pkgname, [fpath] )
				module = imp.load_module(pkgfqn, fp, pathname, description)
				if( fp ): fp.close()
				sys.modules[pkgfqn] = module
					
		except Exception as e:
		# -- LOAD FROM SYS PATHS -----------------------------------------------
			#TODO!!!
			raise

		# -- INSTANTIATE CLASS OBJECT FROM MODULE ------------------------------
		#instantiate the class
		cls = getattr(module, classname, None)
		if(not cls):
			raise NameError("Module [%s] is missing the attribute/class [%s] in %s" % (modulename, classname, os.path.abspath(fpath)) )
		#Ensure the class will work with Twisted / Inherits from referenceable!
		if( not issubclass(cls, pb.Referenceable) ):
			raise TypeError("Class cannot be loaded - [%s.%s] must be a subclass of 'twisted.spread.pb.Referenceable' " % (modulename, cls.__name__) )
		#Instantiate the referenceable
		ref = cls()
		#Optionally if a clientConnectionMade event-method is specified call it...
		#This is how you should get a reference to the application instance, 
		#and the Server root object instance inside your called Referenceable
		if(hasattr(ref, 'clientConnectionMade') and callable(ref.clientConnectionMade)):
			app = self
			yield defer.maybeDeferred(ref.clientConnectionMade, app)
		
		defer.returnValue(ref)
		'''

	@classmethod
	def applicationRegistered(cls, serverobj):
		'''
		Called when the application is first registered (imported) into the 
		server
		
		Application modules are only registered once.  Once they are registered
		client applications can request the application.
		Facilities can be created to load application modules on-demand when
		they are requested for the first time to save resources but this is not
		currently implemented.
		
		It is planned that the cli interface to this server (a pb client) will
		provide a mechanism to load-in applications.
	
		The standard configuration to this server will include search 
		directories from which applications will automatically be loaded as
		well as explicity commands.
	
		Each application module should be installed to a standard path, and
		contain it's own configuration. Each application should be installed
		through an .egg file.

		Args:
			cls[PbApplication] this class object
			serverobj[pb.Root] The server root object
		'''
		print "--%s Registered--" % cls.__name__
		pass
	
	@classmethod
	def applicationUnregistered(cls):
		"""
		Called when the application is unregistered registered from the
		server.
		
		Return value is ignored.
		"""
		pass # This is a place holder.
	
	@classmethod
	def _server_register(cls, server):
		"""
		Called by the server when the application is registered. Subclasses
		wishing to be informed of when an application is registered should
		override *applicationRegistered*.
		
		*server* (``PbServerRoot``) is the server that registered us.
		"""
		# Store reference to application's module to prevent reloading.
		cls.__modules = {
			cls.__module__: server.modules[cls.__name__][0]
		}
		# Notify subclasses.
		cls.applicationRegistered(server)
	
	@classmethod
	def _server_unregister(cls):
		"""
		Called by the server when the application is unregistered.
		Subclasses wishing to be informed of when an application is
		unregistered should override *applicationUnregistered*.
		"""
		# Destroy circular reference to application's module.
		del cls.__modules
		# Notify subclasses.
		cls.applicationUnregistered()


class PbServerFactory(pb.PBServerFactory):
	#protocol = Broker
	'''
	We implement our own server factory to listen for clientConnectionMade()
	events.
	'''
	def clientConnectionMade(self, protocol):
		'''
		Probably want to forward this event to the app class.
		'''
		print "--clientConnectionMade--"
	

import imp
import os.path
class PbServerRoot(pb.Root):
	modules = {}

	@defer.inlineCallbacks
	def remote_application(self, appname):
		'''
		Retrieve the application object for a specific application.  If the 
		application is not found, or is not defined an exception is raised.

		This is called from the client.
		The client retrieves this root object (which is passed into the
		ServerFactory() on the server side) The client then calls this method to
		load the application they are interested in.  The application object
		returned can be thought of as the "Application Root"
		'''
		ref = self.modules[appname][0].application(self)
		
		yield defer.maybeDeferred(ref.clientConnectionMade)
		defer.returnValue(ref)

	def register_app(self, module, path):
		'''
		Manually register an application

		Dev Notes:
			I'm not sure if this logic should be in the Application  class or not as a class method instead of an instance method here?
			I think it belongs here, because these functions can be wrapped by 'remote_' methods to be callable...
		
		Raises:
			ImportError
			AttributeError
			TypeError

		Returns: PbApplication Class
		'''
		fp, pathname, description = imp.find_module(module, [path])
		m = imp.load_module(module, fp, pathname, description)
		if( fp ): fp.close()
		if(not hasattr(m, 'application') ):
			raise AttributeError("PB Application cannot be loaded - missing attribute 'application' in module -> [%s] in %s" % (module, os.path.abspath(path)))
		if( not issubclass(m.application, PbApplication) ):
			raise TypeError("PB Application cannot be loaded - [%s] must be a subclass of 'PbApplication' " % m.application.__name__)

		# module, name, path
		self.modules[m.application.__name__] = (m, module, path)
		
		m.application._server_register(self)
		#m.application.applicationRegistered(self)
		return m.application
		
	def unregister_app(self, module, path):
		'''
		Unregister / Close a program.
		'''
		if module not in self.modules:
			return
		
		#TODO finish this...
		
		#
		appmod = self.modules[module][0]
		appmod.application._server_unregister()
		
		del self.modules[appname]

	def app_path(self, appname):
		'''
		Get the module path of a loaded application
		
		Args:
			appname [str] The name of the application's class
		'''
		return self.modules[appname][2]



class AppManager():
	'''
	This should be the administrative component of the Application-Plugin model (???)
	Manage applications, handle application imports, application paths, 
	application configurations, etc.
	-events
	-logging
	-syspath
	-security
	-security methods
	-security configurations (ip, ldap, pam)
	-development overrides
	'''

class PbGateway():
	'''
	A class to manage client-connectivity
	'''
	CONNECTED = 1
	CONNECTING = 2
	DISCONNECTED = 0
	
	status = DISCONNECTED

	lasterror = None
	errors = []
	factory = None

	def __init__(self, host, port):
		self.host = host
		self.port = port

	@defer.inlineCallbacks
	def connect(self, timeout=10):
		'''
		Connect to the remote
		'''
		self.status = self.CONNECTING
		try:
			self.factory = pb.PBClientFactory()
			self.factoryConnectionLost = self.factory.clientConnectionLost
			self.factory.clientConnectionLost = self.clientConnectionLost
			reactor.connectTCP(self.host, self.port, self.factory, timeout=timeout)
			self.server = yield self.factory.getRootObject()
			self.status = self.CONNECTED
		except Exception as e:
			self.lasterror = e.__class__.__name__+" "+str(e)
			self.errors.append(self.lasterror)
		defer.returnValue( self.server )

	def reconnect(self, asdf):
		#TODO
		# use this to reconnect when connection / broker is lost or stale.
		raise NotImplemented("Todo...")

	@defer.inlineCallbacks
	def application(self, app):
		'''
		Retrieve an application object by name.
		The application must be registered on the server in order to be callable!

		Args:
			app[str] The name of the registered application class

		Returns: app_reference[pb.Referenceable]
		'''
		assert self.status == self.CONNECTED
		
		appinst = yield self.server.callRemote('application', app)
		defer.returnValue(appinst)
		

	def disconnect(self):
		'''
		Disconnect / Clean-Up from the server
		'''
		self.factory.disconnect()

	def clientConnectionLost(self, connector, reason, reconnecting=0):
		'''
		Called when client is disconnected - wraps factory.clientConnectionLost()
		'''
		self.status = self.DISCONNECTED
		self.factoryConnectionLost(connector, reason, reconnecting)

