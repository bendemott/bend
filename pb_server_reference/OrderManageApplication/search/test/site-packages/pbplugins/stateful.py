'''
This API wraps the client-side gateway of Twisted Perspective Broker. 
It should be able to handle states that connection could be in from client-to-server.
This includes handling connecting, disconnecting, reconnecting( detecting it and handling it).
	Goals:
		Detect Stale
		Detect Timeout
		Detect Loss Connection
		FactoryConnectionLost
'''

from twisted.internet import reactor, defer
from twisted.python import failure, log, util
from twisted.spread import pb
from twisted.cred.credentials import UsernamePassword
from twisted.internet import error as netError

import time

class ReconnectQueueLimit(Exception):
	pass
	
class ApplicationNotReady(Exception):
	'''
	This exception can only be raised when the server has just finished
	reconnecting, but isn't quite done setting up the internal Factory again.
	Calls that receive this error just need to wait a split second and attempt
	their call again.
	'''
	pass

class PbClientApplication():
	reconnect_cbs = []
	is_reconnecting = False
	reconnect_queue_max = 5
	
	def __init__(self, appname, host=None, port=None, factory=None, timeout=10):
		'''
		Use factory if defined, assume factory is a Class Object
		'''
		self.appname = appname
		self.host = host
		self.port = port
		self.factoryarg = factory  #allows for custom factory to be passed

			
	@defer.inlineCallbacks
	def connect(self,host=None, port=None, timeout=None):
		self.factory = None
		self.root = None
		self.app = None
		if self.factoryarg is None:
			self.factory = pb.PBClientFactory()
		else:
			#Use custom factory if defined
			self.factory = self.factoryarg()
		#Check to see if we are already conntected, if we are don't quit
		reactor.connectTCP(self.host, self.port, self.factory, timeout=timeout)
		self.root = yield self.factory.getRootObject()
		self.app = yield self.root.callRemote('application', self.appname)
		defer.returnValue(True)
		
	@defer.inlineCallbacks
	def disconnect(self):
		try:
			yield self.factory.disconnect()
			defer.returnValue(True)
		except Exception as e:
			defer.returnValue(False)
		
	@defer.inlineCallbacks
	def reconnect(self):
		'''
		Todo repass security tokens
		'''
		#TODO possible deal with condition when this is called but we
		#are already reconnected
		if not self.is_reconnecting:
			self.is_reconnecting = True
			yield self.disconnect()
			d = self.connect()
			d.addCallback(self._on_reconnect, True)
			d.addErrback(self._on_reconnect, False)

		#Limit the number of items that can queue 
		elif len(self.reconnect_cbs) >= self.reconnect_queue_max:
			raise ReconnectQueueLimit("reconnect-wait queue limit reached")
			
		d2 = defer.Deferred()
		self.reconnect_cbs.append(d2)
		yield d2
	
	def _on_reconnect(self, instance, success):
		print "RECONNECTED"
		#print instance, success
		#XXX this is a test to see if waiting stop some reconnection anomolies

		self.is_reconnecting = False
		for i in xrange(len(self.reconnect_cbs)):
			d = self.reconnect_cbs.pop()
			print "Calling Deferred %s" % d
			if(success):
				d.callback(True)
			else:
				d.errback("Reconnect Failure")
		
	@defer.inlineCallbacks
	def new(self, module, cls):
		'''
		Create new application
		'''
		if not self.app:
			raise ApplicationNotReady()
		ref = yield self.app.callRemote('new', module, cls)
		#If ref is not remote referenceable, raise TODO
		refwrapper = PbReferenceableClient(self, ref, module, cls)
		defer.returnValue(refwrapper)
		
class PbReferenceableClient():
	'''
	This class wraps the twisted Perspective Broker Referenceable
	We do this to make it so broken referenceable's have an opportunity to
	automatically fix themselves without the parent code ever knowing.
	'''
	
	def __init__(self, application, referenceable, module, cls):
		self.application = application
		self.referenceable = referenceable
		self.module = module
		self.cls = cls
		
	@defer.inlineCallbacks
	def callRemote(self, *args, **kwargs):
		'''
		Call the remote-proxy-class method
		'''
		try:
			value = yield self.referenceable.callRemote(*args, **kwargs)
			defer.returnValue( value )
		except (pb.PBConnectionLost, pb.DeadReferenceError) as e:
			'''
			TODO In this except statement we need to not try to reconnect on
			conditions when the user simply called the wrong function or the
			remote function raises an exception (server-side)
			'''
			#Ask for the application to renew it's connection
		
			#Our connection to the server is no longer valid, so we need to
			#request that the application reconnect itself.
			#If the application is already in the process of re-connecting this
			#will enter us into a defer queue to be notified when the server
			#is ready again.
			yield self.application.reconnect()
			
			#Because our remote object is invalid, we have to request a new
			#version of servide side referenceable that will be valid, and retry
			#the request.
			value = None
			attempts = 0
			while 1:
				attempts += 1
				if(attempts > 3):
					raise Exception("Max Request Attempts Reached")
				try:
					self.referenceable = yield self.application.new(self.module, self.cls)
					value = yield self.referenceable.callRemote(*args, **kwargs)
					break
				except (pb.PBConnectionLost, pb.DeadReferenceError, ApplicationNotReady) as e:
					print "EXCEPTION CLASS NAME"
					print e.__class__.__name__
					d = defer.Deferred()
					reactor.callLater(0.1, d.callback, None)
					yield d
			defer.returnValue( value )
		except pb.Error as e:
			raise
		"""
		except StaleBrokerError as e: #???  TODO figure out these errors
			#Ask for the application to renew it's connection
			yield self.application.reconnect()
			#RE ENTERS HERE
			#thisdeferred = self.application.reconnect()
			#build a new version of ourselves
			yield self.application.new(self.module, self.cls)
		except NoConnectionError as e:  #???
			pass
		except RequestTimeoutError as e: #???
			pass
		"""
